/**
 * This file has been autogenerated by LGNC assembler on 2020-09-21 18:19:54 +0000 (1600712394.844089).
 * All changes will be lost on next assembly.
 */

import Foundation
import LGNCore
import LGNP
import LGNC
import LGNS
import Entita
import NIO

public extension Services {
    enum Auth: Service {
        public enum Contracts {}

        public static let transports: [LGNCore.Transport: Int] = [
            .LGNS: 27020,
            .HTTP: 8080,
        ]

        public static let info: [String: String] = [
            "foo": "bar",
        ]

        public static var guaranteeStatuses: [String: Bool] = [
            Contracts.Authenticate.URI: Contracts.Authenticate.isGuaranteed,
            Contracts.Login.URI: Contracts.Login.isGuaranteed,
            Contracts.Signup.URI: Contracts.Signup.isGuaranteed,
        ]

        public static let contractMap: [String: AnyContract.Type] = [
            Contracts.Authenticate.URI: Contracts.Authenticate.self,
            Contracts.Login.URI: Contracts.Login.self,
            Contracts.Signup.URI: Contracts.Signup.self,
        ]

        public static let keyDictionary: [String: Entita.Dict] = [
            "Authenticate": [
                "Request": Contracts.Authenticate.Request.keyDictionary,
                "Response": Contracts.Authenticate.Response.keyDictionary,
            ],
            "Login": [
                "Request": Contracts.Login.Request.keyDictionary,
                "Response": Contracts.Login.Response.keyDictionary,
            ],
            "Signup": [
                "Request": Contracts.Signup.Request.keyDictionary,
                "Response": Contracts.Signup.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Auth.Contracts {
    typealias Good = Services.Shared.Good

    enum Authenticate: Contract {
        public typealias ParentService = Services.Auth

        public static let URI = "Authenticate"
        public static let transports: [LGNCore.Transport] = [.LGNS, .HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let token: LGNC.Entity.Cookie

            public init(token: LGNC.Entity.Cookie) {
                self.token = token
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "token",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let token: LGNC.Entity.Cookie?
                do {
                    token = try self.extractCookie(param: "token", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "token": eventLoop
                        .submit {
                            guard let _ = token else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            token: token!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let IDUser: Int?

            public init(IDUser: Int? = nil) {
                self.IDUser = IDUser
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "IDUser",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let IDUser: Int?? = try? (self.extract(param: "IDUser", from: dictionary, isOptional: true) as Int?)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "IDUser": eventLoop
                        .submit {
                            guard let IDUser = IDUser else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                            if IDUser == nil {
                                throw Validation.Error.SkipMissingOptionalValueValidators()
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            IDUser: IDUser!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    IDUser: try Response.extract(param: "IDUser", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("IDUser"): try self.encode(self.IDUser),
                ]
            }

        }
    }

    enum Login: Contract {
        public typealias ParentService = Services.Auth

        public static let URI = "Login"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let email: String
            public let password: String
            public let recaptchaToken: String?

            public init(email: String, password: String, recaptchaToken: String? = nil) {
                self.email = email
                self.password = password
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "email",
                        "password",
                        "recaptchaToken",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let password: String? = try? (self.extract(param: "password", from: dictionary) as String)
                let recaptchaToken: String?? = try? (self.extract(param: "recaptchaToken", from: dictionary, isOptional: true) as String?)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "email": eventLoop
                        .submit {
                            guard let _ = email else {
                                throw Validation.Error.MissingValue(context.locale, message: "Please enter email")
                            }
                        },
                    "password": eventLoop
                        .submit {
                            guard let _ = password else {
                                throw Validation.Error.MissingValue(context.locale, message: "Please enter password")
                            }
                        },
                    "recaptchaToken": eventLoop
                        .submit {
                            guard let recaptchaToken = recaptchaToken else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                            if recaptchaToken == nil {
                                throw Validation.Error.SkipMissingOptionalValueValidators()
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            email: email!,
                            password: password!,
                            recaptchaToken: recaptchaToken!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    email: try Request.extract(param: "email", from: dictionary),
                    password: try Request.extract(param: "password", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary, isOptional: true)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("password"): try self.encode(self.password),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let userID: Int
            public let token: LGNC.Entity.Cookie

            public init(userID: Int, token: LGNC.Entity.Cookie) {
                self.userID = userID
                self.token = token
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "userID",
                        "token",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let userID: Int? = try? (self.extract(param: "userID", from: dictionary) as Int)
                let token: LGNC.Entity.Cookie?
                do {
                    token = try self.extractCookie(param: "token", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "userID": eventLoop
                        .submit {
                            guard let _ = userID else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "token": eventLoop
                        .submit {
                            guard let _ = token else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            userID: userID!,
                            token: token!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    userID: try Response.extract(param: "userID", from: dictionary),
                    token: try Response.extract(param: "token", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("userID"): try self.encode(self.userID),
                    self.getDictionaryKey("token"): try self.encode(self.token),
                ]
            }

        }
    }

    enum Signup: Contract {
        public typealias ParentService = Services.Auth

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "Signup"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            private static var validatorUsernameClosure: Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback? = nil
            private static var validatorEmailClosure: Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback? = nil

            public enum CallbackValidatorUsernameAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenUsernameAlreadyExists = "User with given username already exists"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                        case .UserWithGivenUsernameAlreadyExists: return (message: self.rawValue, code: 10001)
                    }
                }
            }

            public enum CallbackValidatorEmailAllowedValues: String, CallbackWithAllowedValuesRepresentable, ValidatorErrorRepresentable {
                public typealias InputValue = String

                case UserWithGivenEmailAlreadyExists = "User with given email already exists"

                public func getErrorTuple() -> (message: String, code: Int) {
                    switch self {
                        case .UserWithGivenEmailAlreadyExists: return (message: self.rawValue, code: 10002)
                    }
                }
            }

            public let username: String
            public let email: String
            public let password1: String
            public let password2: String
            public let sex: String
            public let language: String
            public let recaptchaToken: String

            public init(
                username: String,
                email: String,
                password1: String,
                password2: String,
                sex: String,
                language: String,
                recaptchaToken: String
            ) {
                self.username = username
                self.email = email
                self.password1 = password1
                self.password2 = password2
                self.sex = sex
                self.language = language
                self.recaptchaToken = recaptchaToken
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "username",
                        "email",
                        "password1",
                        "password2",
                        "sex",
                        "language",
                        "recaptchaToken",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let username: String? = try? (self.extract(param: "username", from: dictionary) as String)
                let email: String? = try? (self.extract(param: "email", from: dictionary) as String)
                let password1: String? = try? (self.extract(param: "password1", from: dictionary) as String)
                let password2: String? = try? (self.extract(param: "password2", from: dictionary) as String)
                let sex: String? = try? (self.extract(param: "sex", from: dictionary) as String)
                let language: String? = try? (self.extract(param: "language", from: dictionary) as String)
                let recaptchaToken: String? = try? (self.extract(param: "recaptchaToken", from: dictionary) as String)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "username": eventLoop
                        .submit {
                            guard let _ = username else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }
                        .flatMap {
                            if let error = Validation.Regexp(pattern: "^[a-zA-Zа-яА-Я0-9_\\- ]+$", message: "Username must only consist of letters, numbers and underscores").validate(username!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        }

                        .flatMap {
                            if let error = Validation.Length.Min(length: 3).validate(username!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        }

                        .flatMap {
                            if let error = Validation.Length.Max(length: 24).validate(username!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        }

                        .flatMap {
                            guard let validator = self.validatorUsernameClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>(callback: validator).validate(
                                username!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                    "email": eventLoop
                        .submit {
                            guard let _ = email else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }
                        .flatMap {
                            if let error = Validation.Regexp(pattern: "^.+@.+\\..+$", message: "Invalid email format").validate(email!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        }

                        .flatMap {
                            guard let validator = self.validatorEmailClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>(callback: validator).validate(
                                email!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                    "password1": eventLoop
                        .submit {
                            guard let _ = password1 else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }
                        .flatMap {
                            if let error = Validation.Length.Min(length: 6, message: "Password must be at least 6 characters long").validate(password1!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        }

                        .flatMap {
                            if let error = Validation.Length.Max(length: 64, message: "Password must be less than 64 characters long").validate(password1!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                    "password2": eventLoop
                        .submit {
                            guard let _ = password2 else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }
                        .flatMap {
                            if let error = Validation.Identical(right: password1!, message: "Passwords must match").validate(password2!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                    "sex": eventLoop
                        .submit {
                            guard let _ = sex else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }
                        .flatMap {
                            if let error = Validation.In(allowedValues: ["Male", "Female", "Attack helicopter"]).validate(sex!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                    "language": eventLoop
                        .submit {
                            guard let _ = language else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }
                        .flatMap {
                            if let error = Validation.In(allowedValues: ["en", "ru"]).validate(language!, context.locale) {
                                return eventLoop.makeFailedFuture(error)
                            }
                            return eventLoop.makeSucceededFuture()
                        },
                    "recaptchaToken": eventLoop
                        .submit {
                            guard let _ = recaptchaToken else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0.mapValues { [$0] })
                        }

                        return self.init(
                            username: username!,
                            email: email!,
                            password1: password1!,
                            password2: password2!,
                            sex: sex!,
                            language: language!,
                            recaptchaToken: recaptchaToken!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    username: try Request.extract(param: "username", from: dictionary),
                    email: try Request.extract(param: "email", from: dictionary),
                    password1: try Request.extract(param: "password1", from: dictionary),
                    password2: try Request.extract(param: "password2", from: dictionary),
                    sex: try Request.extract(param: "sex", from: dictionary),
                    language: try Request.extract(param: "language", from: dictionary),
                    recaptchaToken: try Request.extract(param: "recaptchaToken", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("username"): try self.encode(self.username),
                    self.getDictionaryKey("email"): try self.encode(self.email),
                    self.getDictionaryKey("password1"): try self.encode(self.password1),
                    self.getDictionaryKey("password2"): try self.encode(self.password2),
                    self.getDictionaryKey("sex"): try self.encode(self.sex),
                    self.getDictionaryKey("language"): try self.encode(self.language),
                    self.getDictionaryKey("recaptchaToken"): try self.encode(self.recaptchaToken),
                ]
            }

            public static func validateUsername(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorUsernameAllowedValues>.Callback
            ) {
                self.validatorUsernameClosure = callback
            }

            public static func validateEmail(
                _ callback: @escaping Validation.CallbackWithAllowedValues<CallbackValidatorEmailAllowedValues>.Callback
            ) {
                self.validatorEmailClosure = callback
            }

        }
    }
}
