/**
 * This file has been autogenerated by LGNC assembler on 2020-09-24 13:30:43 +0000 (1600954243.274313).
 * All changes will be lost on next assembly.
 */

import Foundation
import LGNCore
import LGNP
import LGNC
import LGNS
import Entita
import NIO

public extension Services {
    enum Shop: Service {
        public enum Contracts {}

        public static let transports: [LGNCore.Transport: Int] = [
            .LGNS: 27021,
            .HTTP: 8080,
        ]

        public static let info: [String: String] = [
            "baz": "sas",
        ]

        public static var guaranteeStatuses: [String: Bool] = [
            Contracts.DummyContract.URI: Contracts.DummyContract.isGuaranteed,
            Contracts.Goods.URI: Contracts.Goods.isGuaranteed,
            Contracts.Purchases.URI: Contracts.Purchases.isGuaranteed,
        ]

        public static let contractMap: [String: AnyContract.Type] = [
            Contracts.DummyContract.URI: Contracts.DummyContract.self,
            Contracts.Goods.URI: Contracts.Goods.self,
            Contracts.Purchases.URI: Contracts.Purchases.self,
        ]

        public static let keyDictionary: [String: Entita.Dict] = [
            "DummyContract": [
                "Request": Contracts.DummyContract.Request.keyDictionary,
                "Response": Contracts.DummyContract.Response.keyDictionary,
            ],
            "Goods": [
                "Request": Contracts.Goods.Request.keyDictionary,
                "Response": Contracts.Goods.Response.keyDictionary,
            ],
            "Purchases": [
                "Request": Contracts.Purchases.Request.keyDictionary,
                "Response": Contracts.Purchases.Response.keyDictionary,
            ],
        ]
    }
}

public extension Services.Shop.Contracts {
    typealias Good = Services.Shared.Good

    enum DummyContract: Contract {
        public typealias ParentService = Services.Shop

        public typealias Response = LGNC.Entity.Empty

        public static let URI = "DummyContract"
        public static let transports: [LGNCore.Transport] = [.LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            private static var validatorSomeFieldClosure: Validation.Callback<String>.Callback? = nil

            public let someField: String

            public init(someField: String) {
                self.someField = someField
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "someField",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let someField: String? = try? (self.extract(param: "someField", from: dictionary) as String)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "someField": eventLoop
                        .submit {
                            guard let _ = someField else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        }
                        .flatMap {
                            guard let validator = self.validatorSomeFieldClosure else {
                                return eventLoop.makeSucceededFuture()
                            }
                            return Validation.Callback<String>(callback: validator).validate(
                                someField!,
                                context.locale,
                                on: eventLoop
                            ).mapThrowing { maybeError in if let error = maybeError { throw error } }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            someField: someField!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    someField: try Request.extract(param: "someField", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("someField"): try self.encode(self.someField),
                ]
            }

            public static func validateSomeField(
                _ callback: @escaping Validation.Callback<String>.Callback
            ) {
                self.validatorSomeFieldClosure = callback
            }

            public static func validateSomeField(
                _ callback: @escaping Validation.Callback<String>.CallbackWithSingleError
            ) {
                self.validateSomeField { (value, eventLoop) -> EventLoopFuture<[ErrorTuple]?> in
                    callback(value, eventLoop).map { $0.map { [$0] } }
                }
            }

        }
    }

    enum Goods: Contract {
        public typealias ParentService = Services.Shop

        public typealias Request = LGNC.Entity.Empty

        public static let URI = "Goods"
        public static let transports: [LGNCore.Transport] = [.HTTP, .LGNS]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases

        static let visibility: ContractVisibility = .Private

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let list: [Services.Shared.Good]

            public init(list: [Services.Shared.Good]) {
                self.list = list
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "list",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let list: [Services.Shared.Good]? = try? (self.extract(param: "list", from: dictionary) as [Services.Shared.Good])

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "list": eventLoop
                        .submit {
                            guard let _ = list else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            list: list!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    list: try Response.extract(param: "list", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("list"): try self.encode(self.list),
                ]
            }

        }
    }

    enum Purchases: Contract {
        public typealias ParentService = Services.Shop

        public static let URI = "Purchases"
        public static let transports: [LGNCore.Transport] = [.HTTP]
        public static var guaranteeClosure: Optional<Closure> = nil
        public static let contentTypes: [LGNCore.ContentType] = LGNCore.ContentType.allCases
        public static let isGETSafe = true

        static let visibility: ContractVisibility = .Private

        public final class Request: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public static let hasCookieFields: Bool = true

            public let token: LGNC.Entity.Cookie
            public let page: Int
            public let ignoreFree: Bool

            public init(token: LGNC.Entity.Cookie, page: Int, ignoreFree: Bool) {
                self.token = token
                self.page = page
                self.ignoreFree = ignoreFree
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Request> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "token",
                        "page",
                        "ignoreFree",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let token: LGNC.Entity.Cookie?
                do {
                    token = try self.extractCookie(param: "token", from: dictionary, context: context)
                } catch {
                    return eventLoop.makeFailedFuture(error)
                }
                let page: Int? = try? (self.extract(param: "page", from: dictionary) as Int)
                let ignoreFree: Bool? = try? (self.extract(param: "ignoreFree", from: dictionary) as Bool)

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "token": eventLoop
                        .submit {
                            guard let _ = token else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "page": eventLoop
                        .submit {
                            guard let _ = page else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                    "ignoreFree": eventLoop
                        .submit {
                            guard let _ = ignoreFree else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            token: token!,
                            page: page!,
                            ignoreFree: ignoreFree!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    token: try Request.extract(param: "token", from: dictionary),
                    page: try Request.extract(param: "page", from: dictionary),
                    ignoreFree: try Request.extract(param: "ignoreFree", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("token"): try self.encode(self.token),
                    self.getDictionaryKey("page"): try self.encode(self.page),
                    self.getDictionaryKey("ignoreFree"): try self.encode(self.ignoreFree),
                ]
            }

        }

        public final class Response: ContractEntity {
            public static let keyDictionary: [String: String] = [:]

            public let list: [Services.Shared.Good]

            public init(list: [Services.Shared.Good]) {
                self.list = list
            }

            public static func initWithValidation(
                from dictionary: Entita.Dict, context: LGNCore.Context
            ) -> EventLoopFuture<Response> {
                let eventLoop = context.eventLoop

                if let error = self.ensureNecessaryItems(
                    in: dictionary,
                    necessaryItems: [
                        "list",
                    ]
                ) {
                    return eventLoop.makeFailedFuture(error)
                }

                let list: [Services.Shared.Good]? = try? (self.extract(param: "list", from: dictionary) as [Services.Shared.Good])

                let validatorFutures: [String: EventLoopFuture<Void>] = [
                    "list": eventLoop
                        .submit {
                            guard let _ = list else {
                                throw Validation.Error.MissingValue(context.locale)
                            }
                        },
                ]

                return self
                    .reduce(validators: validatorFutures, context: context)
                    .flatMapThrowing {
                        guard $0.count == 0 else {
                            throw LGNC.E.DecodeError($0)
                        }

                        return self.init(
                            list: list!
                        )
                    }
            }

            public convenience init(from dictionary: Entita.Dict) throws {
                self.init(
                    list: try Response.extract(param: "list", from: dictionary)
                )
            }

            public func getDictionary() throws -> Entita.Dict {
                [
                    self.getDictionaryKey("list"): try self.encode(self.list),
                ]
            }

        }
    }
}